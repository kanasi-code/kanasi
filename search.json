[{"title":"拆解Http keep-alive","url":"/2019/07/23/拆解Http-keep-alive/"},{"title":"kubernetes 学习笔记","url":"/2019/07/16/kubernetes-学习笔记/","content":"# 大纲\n\n## kubernetes 介绍\n\n#### kubernetes 集群架构\n\n- master 节点\n\n  > 控制和管理整个集群系统的控制面板\n\n  - Kubernetes API 服务器\n    - Scheduler  调度器，用于调度你的应用\n  - Controller Manager 执行集群级别的功能，如复制组建、持续跟踪工作节点、处理失败节点\n  - etcd 可靠的分布式存储，用于持久化集群配置\n\n- worker 节点\n\n  > 运行容器化应用的机器 \n\n  - kubelet，与API服务器通信，并管理它所在节点的容器\n  - Docker/rtk 容器应用\n  - kube-proxy 负责组件之间的负载均衡网络流量\n\n#### kubernetes 的好处\n\n- 简化应用程序部署\n- \b更好的利用硬件\n- 健康检查和自修复\n- 自动扩容\n\n## 核心组件\n\n### Service\n\n- ClusterIP\n\n  > Kubernetes 的默认服务，定义一个集群内的服务，集群内的其他应用都可以访问该服务。集群外部无法访问它\n\n- LoadBalancer\n\n  > LoadBalancer 服务是暴露服务到internet的标准方式。通过在集群中创建一个负载均衡器来暴露对应服务，它将给你一个单独IP，转发所有流量到你的服务。\n\n- NodePort\n\n  > 将外部流量引导到内部服务的最原始方式，在所有节点（虚拟机）上开放一个特定端口，任何发送到该端口的流量都会被转发到对应服务\n\n##### 列出所有service\n\n> k get services\n\n\n\n### pod\n\n> 一个pod是一组紧密相关的容器，它们总是一起运行在同一个工作节点上，以及同一个Linux命名空间中，每个pod就像一个独立的逻辑机器，拥有自己的IP、主机名、进程等，运行一个独立的应用程序。\n\n##### 相关命令\n\n> k get pods  //获取pods\n>\n> k logs podname  // 获取指定pod的日志\n\n##### 何时在pod中使用多个容器？\n\n- 他们必须要一起运行\n- 他们代表着一个整体的组件\n- 他们必须一起进行扩容缩容\n\n##### yaml\n\n```yaml\napiVersion: V1\nkind: Pod\nmetadata: \n  name: kubia-manual\nspac:\n  containers:\n  - images: luksa/kubia\n    name: kubia\n    ports:\n    - containerPort: 8080\n    protocol: TCP\n```\n\n##### 标签\n\n> 标签是可以附加到资源的任意键值对，用以选择具有该确切标签的资源，用于快读区分出一组有共同特征的资源\n\n- 命令\n\n  > k get pods  - -show-labels //显示pod 对应的标签\n  >\n  > k get pods -l app=pbkd-user-material-task-pbkd //基于特定标签筛选pod\n\n\n\n##### 命令空间\n\n- 命令\n\n  > k  get ns // 列出所有命名空间\n  >\n  > k get pods -n pbkd // 基于命名空间查找pod\n\n- yaml\n\n  ```\n  apiVersion: V1\n  kind: Namespace\n  metadata: \n    name: kubia-manual\n  ```\n\n\n\n##### 停止和移除pod\n\n- 命令\n\n  > k delete pod kubia  //删除单个pod\n  >\n  > k delete pod - - all  //删除命名空间的所有pod\n  >\n  > k delete add - - all //删除所有资源\n\n##### 存活探针（liveness probe）\n\n> kubernetes 通过存活探针检查容器是否还在运行，可以为pod中的每个容器单独指定存活探针，如果检测失败，kubernetes将定期执行探针并重新启动容器\n\n- 三种探测容器的机制\n  - HTTP GET探针，对容器的IP地址执行HTTP GET请求，如果探测器收到响应，并且响应状态码<400 则代表成功，返回状态码错误或没有返回，则代表失败，重新启动容器\n  - TCP套接字探针尝试与容器指定端口建立TCP连接，如果连接成功建立则探测成功。否则容器重新启动\n  - Exec 探针在容器内执行任意命令，并检查命令的退出码。如果状态码是0 则探测成功。\n\n##### ReplicaSet\n\n> 是一种kubernetes 资源，用户确保pod始终保持运行状态，如果他维护的pod因任何原因消失，则ReplicaSet 会注意到缺少了pod，并创建替代的pod\n\n- label selector（标签选择器），用于确定ReplicaSet域内有哪些pod\n- replica count（副本个数），指定运行的pod的数量\n- pod template（pod 模版），用于创建新的副本\n\n\n\n##### 在kubernetes中运行镜像所发生的步骤\n\n![IMG_8589](/img/IMG_8589.JPG)\n\n\n## 服务发现与负载均衡\n\n### 在kubernetes 中，服务发现与负载均衡问题主要有两种方式：\n\n#### Service\n\n> 前面提到，service有三种类型ClusterIP、NodePort、LoadBalancer\n\n这三种类型的服务都可以用来做服务发现，只不过其职责不同：\n\n- ClusterIP 适用于内部服务的发现，会默认分配一个仅集群内部可访问的IP。这样，内部服务可以通过虚拟IP来访问\n- NodePort 适用于需要将服务暴露到外部的场景， 服务会在每台虚拟机上绑定一个端口，这样就可以通过<NodeIP>:NodePort 的方式来访问该服务\n\n![image-20190716201554956](/img/image-20190716201554956.png)\n\n- LoadBalancer 同上，只用于将服务暴露到外部的场景， 不同的是，这种方式需要依赖cloud provider创建一个外部的负载均衡器，并将请求转发到<NodeIP>:NodePort 上\n\n![image-20190716201543371](/img/image-20190716201543371.png)\n\n#### Ingress Controller\n\nService虽然解决了服务发现和负载均衡的问题，但其有些额外的限制，比如： 对外访问时，NodePort类型需要在外部搭建额外的负载均衡，而LoadBalancer  则要求kubernetes必须跑在cloud provider 上。\n\nIngress 就是为了解决这些限制而引入的新资源（并非service的一种），主要用于将服务暴露到cluster外面，并且可以自定义服务的访问策略。\n\nIngress 本身并不会自动创建负载均衡器，cluster中需要运行一个ingress controller来根据ingress的定义来管理负载均衡器。\n\ningress 原理图：\n\n![image-20190716201523964](/img/image-20190716201523964.png)\n\n\n\n"}]